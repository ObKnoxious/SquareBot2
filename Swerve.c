#pragma config(Sensor, dgtl1,  FRLSwerveEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  FRRSwerveEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  RRLSwerveEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  RRRSwerveEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  DriveEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, Sonar,          sensorSONAR_cm)
#pragma config(Motor,  port2,           FRLSwerve,     tmotorVex269, openLoop)
#pragma config(Motor,  port3,           FRRSwerve,     tmotorVex269, openLoop)
#pragma config(Motor,  port4,           RRLSwerve,     tmotorVex269, openLoop)
#pragma config(Motor,  port5,           RRRSwerve,     tmotorVex269, openLoop)
#pragma config(Motor,  port6,           FRLDrive,      tmotorVex269, openLoop)
#pragma config(Motor,  port7,           FRRDrive,      tmotorVex269, openLoop)
#pragma config(Motor,  port8,           RRLDrive,      tmotorVex269, openLoop)
#pragma config(Motor,  port9,           RRRDrive,      tmotorVex269, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task swerveWheelControl();

task drive();

float turnMultiplier = 3.0;

void setDrive(float power)
{
	motor[FRLDrive] = power;
	motor[FRRDrive] = power;
	motor[RRLDrive] = power;
	motor[RRRDrive] = power;
}

void resetSwerveEncoders()
{
	SensorValue[FRLSwerveEnc] = 0;
	SensorValue[FRRSwerveEnc] = 0;
	SensorValue[RRLSwerveEnc] = 0;
	SensorValue[RRRSwerveEnc] = 0;
}

int deadZone = 20;

float getJoystickAngle()
{
	int x = vexRT[Ch1];
	int y = vexRT[Ch2];

	if (abs(x) < deadZone || abs(y) < deadZone) {
		return 0;
	}

	if (y < 0) {
		// angle reversed, flip direction
		x = -x;
		y = -y;
	}

	return atan(x/y);
}

void wheelTurnToAngle(tMotor corner, tSensors sensor, float angle)
{
	float degreesRemaining = getJoystickAngle() - SensorValue[sensor];
	int power = degreesRemaining * turnMultiplier;

	motor[corner] = power;
}

void wheelsTurnToAngle()
{
	float angle = getJoystickAngle();

	wheelTurnToAngle(FRLSwerve, FRLSwerveEnc, angle);
	wheelTurnToAngle(FRRSwerve, FRRSwerveEnc, angle);
	wheelTurnToAngle(RRLSwerve, RRLSwerveEnc, angle);
	wheelTurnToAngle(RRRSwerve, RRRSwerveEnc, angle);
}

task main()
{
	resetSwerveEncoders();

	StartTask(swerveWheelControl);

	StartTask(drive);
}

task swerveWheelControl()
{
	while(true)
	{
		wheelsTurnToAngle();
	}
}

task drive()
{
	while(true)
	{
		if (vexRT[Ch1] != 0 || vexRT[Ch2] != 0)
		{
			setDrive(sqrt((vexRT[Ch1] * vexRT[Ch1]) + (vexRT[Ch2] * vexRT[Ch2])));
		}
	}
}
