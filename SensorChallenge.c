#pragma config(Sensor, in1,    lightSensor,    sensorReflection)
#pragma config(Sensor, in2,    rightLine,      sensorLineFollower)
#pragma config(Sensor, in3,    middleLine,     sensorLineFollower)
#pragma config(Sensor, in4,    leftLine,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl2,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  sonarSensor,    sensorSONAR_cm)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex269, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex269, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int speed = 60;
int slow = 40;
float pie = 3.14;
float dia = 2.75;
float circ = pie*dia;
int backspeed=-1*speed;
int backslow = -1*slow;


void moveForward(float dist)
{
	while (SensorValue[rightEncoder]<360*dist/circ)
	{
		if (SensorValue[sonarSensor]>15 || SensorValue[sonarSensor]<0)
		{
			if (SensorValue[leftEncoder]> SensorValue[rightEncoder])
			{
				motor[leftMotor]= slow;
				motor[rightMotor]= speed;
			}
				if (SensorValue[leftEncoder]< SensorValue[rightEncoder])
			{
				motor[leftMotor]= speed;
				motor[rightMotor]= slow;
			}
				if (SensorValue[leftEncoder]== SensorValue[rightEncoder])
			{
				motor[leftMotor]= speed;
				motor[rightMotor]= speed;
			}
		}
		else
		{
			motor[leftMotor]=0;
			motor[rightMotor]=0;
		}
	}
}

void turnLeft(float angle)
{
	while (SensorValue[rightEncoder]<10*angle/3)
	{
			if (SensorValue[leftEncoder]+ SensorValue[rightEncoder]>0)
			{
				motor[leftMotor]= backspeed;
				motor[rightMotor]= slow;
			}
				if (SensorValue[leftEncoder]+ SensorValue[rightEncoder]<0)
			{
				motor[leftMotor]= backslow;
				motor[rightMotor]= speed;
			}
				if (SensorValue[leftEncoder]+ SensorValue[rightEncoder]==0)
			{
				motor[leftMotor]= backspeed;
				motor[rightMotor]= speed;
			}
	}
}

void turnRight(float angle)
{
	while (SensorValue[leftEncoder]<10*angle/3)
	{
		if (SensorValue[leftEncoder]+ SensorValue[rightEncoder]>0)
		{
			motor[rightMotor]= backspeed;
			motor[leftMotor]= slow;
		}
			if (SensorValue[leftEncoder]+ SensorValue[rightEncoder]<0)
		{
			motor[rightMotor]= backslow;
			motor[leftMotor]= speed;
		}
			if (SensorValue[leftEncoder]+ SensorValue[rightEncoder]==0)
		{
			motor[rightMotor]= backspeed;
			motor[leftMotor]= speed;
		}
	}
}

void clearEncoders()
{
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] =0;

}
void Stop(float time)
{
	motor[rightMotor]= 0;
	motor[leftMotor]= 0;
	wait1Msec(time*1000);

}

task main()
{
		Stop(3);
		while (true)
		{
		clearEncoders();
		moveForward(31);
		Stop(1);
		clearEncoders();
		turnRight(75);
		Stop(1);
		clearEncoders();
		moveForward(76);
		Stop(1);
		clearEncoders();
		turnRight(75);
		Stop(1);
	}
}
